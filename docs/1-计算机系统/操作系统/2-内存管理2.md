我们看看用户空间分布的情况，以 32 位系统为例，我画了一张图来表示它们的关系：

通过这张图你可以看到，用户空间内存从**低到高**分别是 6 种不同的内存段：

![图片](https://img-blog.csdnimg.cn/img_convert/7b5b6b3728acde8df019350df3cb85c1.png)

-   程序文件段，包括二进制可执行代码；
-   已初始化数据段，包括静态常量；
-   未初始化数据段，包括未初始化的静态变量；
-   堆段，包括动态分配的内存，从低地址开始向上增长；
-   文件映射段，包括动态库、共享内存等，从低地址开始向上增长（跟硬件和内核版本有关 ）；
-   栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 `8 MB`。当然系统也提供了参数，以便我们自定义大小；

在这 6 个内存段中，堆和文件映射段的内存是动态分配的。比如说，使用 C 标准库的 `malloc()` 或者 `mmap()` ，就可以分别在堆和文件映射段动态分配内存。



## malloc是如何分配内存的？
实际上，malloc() 并不是系统调用，而是 C 库里的函数，用于动态分配内存。

malloc 申请内存的时候，会有两种方式向操作系统申请堆内存。

-   方式一：通过 brk() 系统调用从堆分配内存
-   方式二：通过 mmap() 系统调用在文件映射区域分配内存；

## malloc分配的是物理内存吗
不是的，**malloc() 分配的是虚拟内存**。

如果分配后的虚拟内存没有被访问的话，虚拟内存是不会映射到物理内存的，这样就不会占用物理内存了。

只有在访问已分配的虚拟地址空间的时候，操作系统通过查找页表，发现虚拟内存对应的页没有在物理内存中，就会触发缺页中断，然后操作系统会建立虚拟内存和物理内存之间的映射关系。

## malloc(1)会分配多大的虚拟内存

132KB

## 为什么不全部使用 mmap 来分配内存？
频繁通过 mmap 分配的内存话，不仅每次都会发生运行态的切换，还会发生缺页中断（在第一次访问虚拟地址后），这样会导致 CPU 消耗较大。









